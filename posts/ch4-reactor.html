<!DOCTYPE HTML>
<html lang="en-US">
    <head prefix="og: http://ogp.me/ns# book: http://ogp.me/ns/book#">
        
        <meta charset="UTF-8">
        <title>Netty与Reactor模式 | Netty-learning</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="robots" content="index, follow">
        <meta name="author" content="code4craft">
        <meta name="description" content="">
        <meta name="keywords" content="gitbook,github" >
        <meta name="generator" content="www.gitbook.io">

        
        <link rel="next" href="../posts/socks-proxy-by-netty.html" />
        
        
        <link rel="prev" href="../posts/ch3-pipeline.html" />
        

        <meta property="og:title" content="Netty与Reactor模式 | Netty-learning">
        <meta property="og:site_name" content="Netty-learning">
        <meta property="og:type" content="book">
        <meta property="og:locale" content="en_US">

        <meta property="book:author" content="https://github.com/code4craft">
        <meta property="book:tag" content="GitBook">

        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">

        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

        
        <link rel="stylesheet" href="../gitbook/style.css">
        
        
    </head>
    <body>
        
<div class="book" data-github="code4craft/netty-learning" data-level="4" data-basepath=".." data-revision="1396882856970">
    <div class="book-header">
    <!-- Actions Left -->
    <a href="https://github.com/code4craft/netty-learning" target="_blank" class="btn pull-left"><i class="fa fa-github-alt"></i></a>
    <a href="#" class="btn pull-left toggle-summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search"><i class="fa fa-search"></i></a>

    <!-- Actions Right -->
    <a href="#" target="_blank" class="btn pull-right" data-sharing="google-plus"><i class="fa fa-google-plus"></i></a>
    <a href="#" target="_blank" class="btn pull-right" data-sharing="facebook"><i class="fa fa-facebook"></i></a>
    <a href="#" target="_blank" class="btn pull-right" data-sharing="twitter"><i class="fa fa-twitter"></i></a>

    <a href="https://github.com/code4craft/netty-learning/stargazers" target="_blank" class="btn pull-right count-star"><i class="fa fa-star-o"></i> Star (<span>-</span>)</a>
    <a href="https://github.com/code4craft/netty-learning/watchers" target="_blank" class="btn pull-right count-watch"><i class="fa fa-eye"></i> Watch (<span>-</span>)</a>


    <!-- Title -->
    <h1><a href="../" >Netty-learning</a></h1>
</div>

    <div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Search" class="form-control" />
    </div>
    <ul class="summary">
        <li>
            <a href="https://github.com/code4craft" target="blank">About the author</a>
        </li>
        <li>
            <a href="https://github.com/code4craft/netty-learning/issues" target="blank">Questions and Issues</a>
        </li>
        <li>
            <a href="https://github.com/code4craft/netty-learning/edit/master/posts/ch4-reactor.md" target="blank">Edit and Contribute</a>
        </li>
        <li class="divider"></li>
        <li data-level="0" data-path="index.html">
            <a href="../"><i class="fa fa-check"></i> Introduction</a>
        </li>
        
            <li  data-level="1" data-path="posts/ch1-overview.html">
                
                <a href="../posts/ch1-overview.html">
                    <i class="fa fa-check"></i> <b>1)</b> Netty概述
                </a>
                
                
            </li>
        
            <li  data-level="2" data-path="posts/ch2-buffer.html">
                
                <a href="../posts/ch2-buffer.html">
                    <i class="fa fa-check"></i> <b>2)</b> Netty中的buffer
                </a>
                
                
            </li>
        
            <li  data-level="3" data-path="posts/ch3-pipeline.html">
                
                <a href="../posts/ch3-pipeline.html">
                    <i class="fa fa-check"></i> <b>3)</b> Channel中的Pipeline
                </a>
                
                
            </li>
        
            <li  data-level="4" data-path="posts/ch4-reactor.html">
                
                <a href="../posts/ch4-reactor.html">
                    <i class="fa fa-check"></i> <b>4)</b> Netty与Reactor模式
                </a>
                
                
            </li>
        
            <li  data-level="5" data-path="posts/socks-proxy-by-netty.html">
                
                <a href="../posts/socks-proxy-by-netty.html">
                    <i class="fa fa-check"></i> <b>5)</b> Netty实战:构建一个socks proxy
                </a>
                
                
            </li>
        
    </ul>
</div>

    <div class="book-body" tabindex="-1">
        <div class="body-inner">
            <div class="page-wrapper">
                <div class="book-progress">
    <div class="bar">
        <div class="inner" style="width: 80%;min-width: 60%;"></div>
    </div>
    <div class="chapters">
    
        <a href="../index.html" title="Introduction" class="chapter done new-chapter" data-progress="0" style="left: 0%;"></a>
    
        <a href="../posts/ch1-overview.html" title="Netty概述" class="chapter done new-chapter" data-progress="1" style="left: 20%;"></a>
    
        <a href="../posts/ch2-buffer.html" title="Netty中的buffer" class="chapter done new-chapter" data-progress="2" style="left: 40%;"></a>
    
        <a href="../posts/ch3-pipeline.html" title="Channel中的Pipeline" class="chapter done new-chapter" data-progress="3" style="left: 60%;"></a>
    
        <a href="../posts/ch4-reactor.html" title="Netty与Reactor模式" class="chapter done new-chapter" data-progress="4" style="left: 80%;"></a>
    
        <a href="../posts/socks-proxy-by-netty.html" title="Netty实战:构建一个socks proxy" class="chapter  new-chapter" data-progress="5" style="left: 100%;"></a>
    
    </div>
</div>

                <div class="page-inner">
                
                    <section class="normal" id="section-gitbook_5">
                    
                        <h2 id="netty-netty-reactor-">Netty那点事（四）Netty与Reactor模式</h2>
<p>![Reactors][1]</p>
<h2 id="-netty-nio-">一：Netty、NIO、多线程？</h2>
<p>时隔很久终于又更新了！之前一直迟迟未动也是因为积累不够，后面比较难下手。过年期间<a href="http://weibo.com/lilinfeng" target="_blank">@李林锋hw</a>发布了一个Netty5.0架构剖析和源码解读 <a href="http://vdisk.weibo.com/s/C9LV9iVqH13rW/1391437855" target="_blank">http://vdisk.weibo.com/s/C9LV9iVqH13rW/1391437855</a>，看完也是收获不少。前面的文章我们分析了Netty的结构，这次咱们来分析最错综复杂的一部分-Netty中的多线程以及NIO的应用。</p>
<p>理清NIO与Netty的关系之前，我们必须先要来看看Reactor模式。Netty是一个典型的多线程的Reactor模式的使用，理解了这部分，在宏观上理解Netty的NIO及多线程部分就不会有什么困难了。</p>
<p>本篇文章依然针对Netty 3.7，不过因为也看过一点Netty 5的源码，所以会有一点介绍。</p>
<h2 id="-reactor-">二：Reactor，反应堆还是核电站？</h2>
<h3 id="1-reactor-">1、Reactor的由来</h3>
<p>Reactor是一种广泛应用在服务器端开发的设计模式。Reactor中文大多译为“反应堆”，我当初接触这个概念的时候，就感觉很厉害，是不是它的原理就跟“核反应”差不多？后来才知道其实没有什么关系，从Reactor的兄弟“Proactor”（多译为前摄器）就能看得出来，这两个词的中文翻译其实都不是太好，不够形象。实际上，Reactor模式又有别名“Dispatcher”或者“Notifier”，我觉得这两个都更加能表明它的本质。</p>
<p>那么，Reactor模式究竟是个什么东西呢？这要从事件驱动的开发方式说起。我们知道，对于应用服务器，一个主要规律就是，CPU的处理速度是要远远快于IO速度的，如果CPU为了IO操作（例如从Socket读取一段数据）而阻塞显然是不划算的。好一点的方法是分为多进程或者线程去进行处理，但是这样会带来一些进程切换的开销，试想一个进程一个数据读了500ms，期间进程切换到它3次，但是CPU却什么都不能干，就这么切换走了，是不是也不划算？</p>
<p>这时先驱们找到了事件驱动，或者叫回调的方式，来完成这件事情。这种方式就是，应用业务向一个中间人注册一个回调（event handler），当IO就绪后，就这个中间人产生一个事件，并通知此handler进行处理。<em>这种回调的方式，也体现了“好莱坞原则”（Hollywood principle）-“Don&#39;t call us, we&#39;ll call you”，在我们熟悉的IoC中也有用到。看来软件开发真是互通的！</em></p>
<p>好了，我们现在来看Reactor模式。在前面事件驱动的例子里有个问题：我们如何知道IO就绪这个事件，谁来充当这个中间人？Reactor模式的答案是：由一个不断等待和循环的单独进程（线程）来做这件事，它接受所有handler的注册，并负责先操作系统查询IO是否就绪，在就绪后就调用指定handler进行处理，这个角色的名字就叫做Reactor。</p>
<h3 id="2-reactor-nio">2、Reactor与NIO</h3>
<p>Java中的NIO可以很好的和Reactor模式结合。关于NIO中的Reactor模式，我想没有什么资料能比Doug Lea大神（不知道Doug Lea？看看JDK集合包和并发包的作者吧）在<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank">《Scalable IO in Java》</a>解释的更简洁和全面了。NIO中Reactor的核心是<code>Selector</code>，我写了一个简单的Reactor示例，这里我贴一个核心的Reactor的循环（这种循环结构又叫做<code>EventLoop</code>），剩余代码在<a href="learning-src/src/main/java/us/codecraft/netty/reactor">learning-src</a>目录下。</p>
<pre><code class="lang-java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">while</span> (!Thread.interrupted()) {
                selector.select();
                Set selected = selector.selectedKeys();
                Iterator it = selected.iterator();
                <span class="hljs-keyword">while</span> (it.hasNext())
                    dispatch((SelectionKey) (it.next()));
                selected.clear();
            }
        } <span class="hljs-keyword">catch</span> (IOException ex) { <span class="hljs-comment">/* ... */</span>
        }
    }
</code></pre>
<h3 id="3-reactor-">3、与Reactor相关的其他概念</h3>
<p>前面提到了Proactor模式，这又是什么呢？简单来说，Reactor模式里，操作系统只负责通知IO就绪，具体的IO操作（例如读写）仍然是要在业务进程里阻塞的去做的，而Proactor模式则更进一步，由操作系统将IO操作执行好（例如读取，会将数据直接读到内存buffer中），而handler只负责处理自己的逻辑，真正做到了IO与程序处理异步执行。所以我们一般又说Reactor是同步IO，Proactor是异步IO。</p>
<p>关于阻塞和非阻塞、异步和非异步，以及UNIX底层的机制，大家可以看看这篇文章<a href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a>，以及陶辉（《深入理解nginx》的作者）<a href="http://blog.csdn.net/russell_tao/article/details/17452997" target="_blank">《高性能网络编程》</a>的系列。</p>
<h2 id="-reactor-netty">三：由Reactor出发来理解Netty</h2>
<h3 id="1-reactor">1、多线程下的Reactor</h3>
<p>讲了一堆Reactor，我们回到Netty。在《Scalable IO in Java》中讲到了一种多线程下的Reactor模式。在这个模式里，mainReactor只有一个，负责响应client的连接请求，并建立连接，它使用一个NIO Selector；subReactor可以有一个或者多个，每个subReactor都会在一个独立线程中执行，并且维护一个独立的NIO Selector。</p>
<p>这样的好处很明显，因为subReactor也会执行一些比较耗时的IO操作，例如消息的读写，使用多个线程去执行，则更加有利于发挥CPU的运算能力，减少IO等待时间。</p>
<p>![Multiple Reactors][2]</p>
<h3 id="2-netty-reactor-nio">2、Netty中的Reactor与NIO</h3>
<p>好了，了解了多线程下的Reactor模式，我们来看看Netty吧（以下部分主要针对NIO，OIO部分更加简单一点，不重复介绍了）。Netty里对应mainReactor的角色叫做“Boss”，而对应subReactor的角色叫做&quot;Worker&quot;。Boss负责分配请求，Worker负责执行，好像也很贴切！以TCP的Server端为例，这两个对应的实现类分别为<code>NioServerBoss</code>和<code>NioWorker</code>（Server和Client的Worker没有区别，因为建立连接之后，双方就是对等的进行传输了）。</p>
<p>Netty 3.7中Reactor的EventLoop在<code>AbstractNioSelector.run()</code>中，它实现了<code>Runnable</code>接口。这个类是Netty NIO部分的核心。它的逻辑非常复杂，其中还包括一些对JDK Bug的处理（例如<code>rebuildSelector</code>），刚开始读的时候不需要深入那么细节。我精简了大部分代码，保留主干如下：</p>
<pre><code class="lang-java"><span class="hljs-keyword">abstract</span> class AbstractNioSelector implements NioSelector {


    <span class="hljs-comment">//NIO Selector</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> Selector selector;

    <span class="hljs-comment">//内部任务队列</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Runnable&gt; taskQueue = <span class="hljs-keyword">new</span> ConcurrentLinkedQueue&lt;Runnable&gt;();

    <span class="hljs-comment">//selector循环</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
        <span class="hljs-keyword">for</span> (;;) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">//处理内部任务队列</span>
                processTaskQueue();
                <span class="hljs-comment">//处理selector事件对应逻辑</span>
                process(selector);
            } <span class="hljs-keyword">catch</span> (Throwable t) {
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(<span class="hljs-number">1000</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    <span class="hljs-comment">// Ignore.</span>
                }
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processTaskQueue</span>() {
        <span class="hljs-keyword">for</span> (;;) {
            <span class="hljs-keyword">final</span> Runnable task = taskQueue.poll();
            <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">break</span>;
            }
            task.run();
        }
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span>(Selector selector) <span class="hljs-keyword">throws</span> IOException;

}
</code></pre>
<p>其中process是主要的处理事件的逻辑，例如在<code>AbstractNioWorker</code>中，处理逻辑如下：</p>
<pre><code class="lang-java">    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span>(Selector selector) <span class="hljs-keyword">throws</span> IOException {
        Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
        <span class="hljs-keyword">if</span> (selectedKeys.isEmpty()) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">for</span> (Iterator&lt;SelectionKey&gt; i = selectedKeys.iterator(); i.hasNext();) {
            SelectionKey k = i.next();
            i.remove();
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">int</span> readyOps = k.readyOps();
                <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_READ) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">if</span> (!read(k)) {
                        <span class="hljs-comment">// Connection already closed - no need to handle write.</span>
                        <span class="hljs-keyword">continue</span>;
                    }
                }
                <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) {
                    writeFromSelectorLoop(k);
                }
            } <span class="hljs-keyword">catch</span> (CancelledKeyException e) {
                close(k);
            }

            <span class="hljs-keyword">if</span> (cleanUpCancelledKeys()) {
                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// break the loop to avoid ConcurrentModificationException</span>
            }
        }
    }
</code></pre>
<p>这不就是第二部分提到的selector经典用法了么？</p>
<p>在Netty 4.0之后，作者觉得<code>NioSelector</code>这个叫法，以及区分<code>NioBoss</code>和<code>NioWorker</code>的做法稍微繁琐了点，干脆就将这些合并成了<code>NioEventLoop</code>，从此这两个角色就不做区分了。我倒是觉得新版本的会更优雅一点。</p>
<h3 id="3-netty-">3、Netty中的多线程</h3>
<p>下面我们来看Netty的多线程部分。一旦对应的Boss或者Worker启动，就会分配给它们一个线程去一直执行。对应的概念为<code>BossPool</code>和<code>WorkerPool</code>。对于每个<code>NioServerSocketChannel</code>，Boss的Reactor有一个线程，而Worker的线程数由Worker线程池大小决定，但是默认最大不会超过CPU核数*2，当然，这个参数可以通过<code>NioServerSocketChannelFactory</code>构造函数的参数来设置。</p>
<pre><code class="lang-java">    <span class="hljs-keyword">public</span> <span class="hljs-title">NioServerSocketChannelFactory</span>(
            Executor bossExecutor, Executor workerExecutor,
            <span class="hljs-keyword">int</span> workerCount) {
        <span class="hljs-keyword">this</span>(bossExecutor, <span class="hljs-number">1</span>, workerExecutor, workerCount);
    }
</code></pre>
<p>最后我们比较关心一个问题，我们之前<code>ChannlePipeline</code>中的ChannleHandler是在哪个线程执行的呢？答案是在Worker线程里执行的，并且会阻塞Worker的EventLoop。例如，在<code>NioWorker</code>中，读取消息完毕之后，会触发<code>MessageReceived</code>事件，这会使得Pipeline中的handler都得到执行。</p>
<pre><code class="lang-java">    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">read</span>(SelectionKey k) {
        ....

        <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// Fire the event.</span>
            fireMessageReceived(channel, buffer);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
</code></pre>
<p>可以看到，对于处理事件较长的业务，并不太适合直接放到ChannelHandler中执行。那么怎么处理呢？我们在Handler部分会进行介绍。</p>
<p>参考资料：</p>
<ul>
<li>Scalable IO in Java <a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></li>
<li>Netty5.0架构剖析和源码解读 <a href="http://vdisk.weibo.com/s/C9LV9iVqH13rW/1391437855" target="_blank">http://vdisk.weibo.com/s/C9LV9iVqH13rW/1391437855</a></li>
<li>Reactor pattern <a href="http://en.wikipedia.org/wiki/Reactor_pattern" target="_blank">http://en.wikipedia.org/wiki/Reactor_pattern</a></li>
<li>Reactor - An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events <a href="http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf" target="_blank">http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf</a></li>
<li>高性能网络编程6--reactor反应堆与定时器管理 <a href="http://blog.csdn.net/russell_tao/article/details/17452997" target="_blank">http://blog.csdn.net/russell_tao/article/details/17452997</a></li>
<li>IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）<a href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank">http://blog.csdn.net/historyasamirror/article/details/5778378</a></li>
</ul>
<p>题图来自：<a href="http://www.worldindustrialreporter.com/france-gives-green-light-to-tokamak-fusion-reactor/" target="_blank">http://www.worldindustrialreporter.com/france-gives-green-light-to-tokamak-fusion-reactor/</a></p>

                    
                    </section>
                
                </div>
            </div>
        </div>

        
        <a href="../posts/ch3-pipeline.html" class="navigation navigation-prev"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../posts/socks-proxy-by-netty.html" class="navigation navigation-next"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/ace.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/mode-javascript.js"></script>
        <script src="../gitbook/jsrepl/jsrepl.js" id="jsrepl-script"></script>
        <script src="../gitbook/app.js"></script>
        
    </body>
</html>
